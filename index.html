<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FNF JSON → Gpop (.gpop) Converter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --pad: 14px; --radius: 10px; }
    html { background: #0b0c10; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      line-height: 1.4; margin: 0;
      background: #0b0c10; color: #e8e8e8;
    }
    .wrap { max-width: 820px; margin: 40px auto; padding: 0 16px; }
    .card { background: #111319; border: 1px solid #1f2430; border-radius: var(--radius); padding: calc(var(--pad) + 2px); box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    h1 { font-size: 1.6rem; margin: 0 0 14px 0; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .spacer { height: 10px; }
    label { font-weight: 600; }
    select, input[type="number"], input[type="text"], input[type="file"] {
      background: #0f1218; color: #e8e8e8; border: 1px solid #2a3140; border-radius: 8px; padding: 8px 10px;
    }
    .btn {
      appearance: none; border: 0; border-radius: 10px; padding: 10px 14px; font-weight: 700; cursor: pointer;
      background: #5b8cff; color: #0b0c10;
    }
    .btn:disabled { opacity: .6; cursor: not-allowed; }
    .hint { color: #9fb0cf; font-size: .95rem; }
    .out { white-space: pre-line; margin-top: 12px; padding: 10px; border: 1px dashed #2a3140; border-radius: 8px; background: #0f1218; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: .95rem; display:none; }
    a.download { display: inline-block; margin-top: 10px; text-decoration: none; font-weight: 700; color: #5b8cff; }
    .tag { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #2a3140; font-size:.85rem; color:#cdd9f0; }

    details.adv {
      border: 1px solid #1f2430; border-radius: 8px; background:#0f1218; padding: 8px 10px;
    }
    details.adv summary { cursor: pointer; font-weight: 700; color:#cdd9f0; list-style: none; }
    details.adv summary::-webkit-details-marker { display: none; }
    details.adv[open] { background:#10141c; }
    .adv-grid { display:grid; grid-template-columns: repeat(auto-fit,minmax(180px,1fr)); gap: 10px; margin-top: 10px; }
    .adv-grid label { display:flex; align-items:center; gap:8px; font-weight:600; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>FNF JSON → Gpop (.gpop)</h1>
      <p class="hint">Select a Friday Night Funkin’ chart JSON and export a <code>.gpop</code>.</p>

      <div class="spacer"></div>

      <div class="row">
        <input id="file" type="file" accept=".json,application/json" />
        <button id="convert" class="btn" disabled>Convert &amp; Download</button>
        <span id="status" class="tag">No file</span>
      </div>

      <div class="spacer"></div>

      <div class="row">
        <label for="offset" title="When the first notes happen in the audio (e.g., 5.3)">offset (s):</label>
        <input id="offset" type="number" step="0.001" inputmode="decimal" placeholder="e.g., 5.300" value="0.000" />
      </div>
      <p class="hint">
        Offset is added after anchoring. Use negative values if notes are slightly ahead of the audio.
      </p>

      <div class="spacer"></div>

      <div class="row">
        <label for="side">Side:</label>
        <select id="side">
          <option value="bf" selected>bf (player)</option>
          <option value="opp">opp (opponent)</option>
          <option value="both">both</option>
        </select>
      </div>

      <div class="spacer"></div>

      <details class="adv">
        <summary>Advanced Options</summary>
        <div class="adv-grid">
          <label><input id="seconds" type="checkbox" checked /> Output in seconds (3 dp)</label>
          <label><input id="shift" type="checkbox" checked /> Shift start to earliest note</label>
          <label>
            anchor:&nbsp;
            <select id="anchor">
              <option value="">auto</option>
              <option value="bf_start">bf_start (first BF note)</option>
              <option value="opp_start">opp_start (first Opp note)</option>
              <option value="none">none</option>
            </select>
          </label>
          <label><input id="nudge" type="checkbox" /> Nudge end −1ms (compatibility)</label>
          <label><input id="showlog" type="checkbox" /> Show debug log</label>
        </div>
      </details>

      <div id="log" class="out"></div>
      <a id="dl" class="download" style="display:none;">Download .gpop</a>
    </div>
  </div>

  <script>
    // Minimal error surfacing (keeps page simple but not silent)
    window.addEventListener('error', (e) => log('Runtime error: ' + (e.message || e.error || e), true));
    window.addEventListener('unhandledrejection', (e) => log('Unhandled rejection: ' + (e.reason && e.reason.message ? e.reason.message : e.reason), true));

    const HEADER = {"type":"s2","dict":{"a":0,"a1":1,"s":2,"s1":3,"d":4,"d1":5,"f":6,"f1":7}};

    const els = {
      file: document.getElementById('file'),
      convert: document.getElementById('convert'),
      status: document.getElementById('status'),
      side: document.getElementById('side'),
      seconds: document.getElementById('seconds'),
      shift: document.getElementById('shift'),
      anchor: document.getElementById('anchor'),
      offset: document.getElementById('offset'),
      nudge:  document.getElementById('nudge'),
      showlog: document.getElementById('showlog'),
      log: document.getElementById('log'),
      dl: document.getElementById('dl')
    };

    let fileHandle = null, fileNameBase = 'output';

    // Live toggle of the log’s visibility (tiny QoL)
    els.showlog.addEventListener('change', () => {
      els.log.style.display = els.showlog.checked ? 'block' : 'none';
    });

    els.file.addEventListener('change', () => {
      const f = els.file.files[0];
      if (!f) { els.status.textContent = 'No file'; els.convert.disabled = true; return; }
      fileHandle = f;
      fileNameBase = f.name.replace(/\.[^.]+$/,'') || 'chart';
      const mb = (f.size / 1048576).toFixed(1);
      els.status.textContent = `Loaded: ${f.name} (${mb} MB)`;
      els.convert.disabled = false;
      hideResult();
    });

    els.convert.addEventListener('click', async () => {
      if (!fileHandle) return;
      try {
        setBusy(true);
        const src = JSON.parse(await fileHandle.text());

        const opts = {
          side: els.side.value,
          seconds: !!els.seconds.checked,
          shift: !!els.shift.checked,
          anchor: els.anchor.value || null,
          offset: parseFloat(els.offset.value || '0') || 0,
          nudge:  !!els.nudge.checked
        };

        const res = convertFNFToGpop(src, opts);

        const json = JSON.stringify(res.output, null, 0);
        const blob = new Blob([json], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const outName = `${fileNameBase}.gpop`;

        els.dl.href = url;
        els.dl.download = outName;
        els.dl.style.display = 'inline-block';
        els.dl.textContent = `Download ${outName}`;

        const tail = res.output.slice(Math.max(0, res.output.length - 20));
        info(
`Wrote ${outName} with ${res.noteCount} notes.
Units: ${opts.seconds ? 'seconds' : 'ms'} | Shifted: ${opts.shift} | Anchor: ${opts.anchor ?? 'auto'} | Offset: ${opts.offset.toFixed(3)}s | Nudge: ${opts.nudge}
Tail → ${JSON.stringify(tail)}`
        );
      } catch (e) {
        log('Error: ' + (e && e.message ? e.message : e), true);
        hideResult();
      } finally {
        setBusy(false);
      }
    });

    function hideResult(){ els.dl.style.display='none'; if (!els.showlog.checked) els.log.style.display='none'; }
    function setBusy(on){
      els.convert.disabled=on; els.file.disabled=on;
      els.status.textContent = on ? 'Converting…' : (fileHandle ? `Loaded: ${fileHandle.name}` : 'No file');
    }
    function info(msg){ if (!els.showlog.checked) return; els.log.textContent = msg; els.log.style.display='block'; els.log.style.borderColor='#2a3140'; }
    function log(msg,isErr=false){
      els.log.textContent = msg;
      els.log.style.display = 'block';
      els.log.style.borderColor = isErr ? '#6b2a2a' : '#2a3140';
    }

    // ---------- Parse ----------
    function loadFNF(data){
      if (data?.song?.notes) return { sections: data.song.notes, raw: data };
      if (Array.isArray(data?.notes)) return { sections: data.notes, raw: data };
      if (Array.isArray(data)) return { sections: data, raw: data };
      return { sections: [], raw: data };
    }

    // Return {t, nd, sus} (sus is sustain length in ms; ignored here)
    function readNoteTriple(n){
      let t = NaN, nd = NaN, sus = 0;
      if (Array.isArray(n)) {
        if (n.length >= 2) { t = Number(n[0]); nd = Number(n[1]); }
        if (n.length >= 3 && Number.isFinite(Number(n[2]))) sus = Number(n[2]);
      } else if (n && typeof n === 'object') {
        t  = Number( ('strumTime' in n) ? n.strumTime : ('time' in n ? n.time : NaN) );
        nd = Number( ('noteData' in n) ? n.noteData  : ('note' in n ? n.note : NaN) );
        const cand = n.sustainLength ?? n.sustain ?? n.hold ?? n.length ?? n.duration;
        if (cand != null && Number.isFinite(Number(cand))) sus = Number(cand);
      }
      if (!Number.isFinite(t) || !Number.isFinite(nd)) return null;
      return { t, nd, sus: Math.max(0, sus) };
    }

    // Section-aware side picking
    function belongsToSide(nd, side, mustHit) {
      const left = nd < 4; // 0..3
      if (mustHit === true) {
        if (side === 'bf')  return left;
        if (side === 'opp') return !left;
      } else if (mustHit === false) {
        if (side === 'bf')  return !left;
        if (side === 'opp') return left;
      } else {
        if (side === 'bf')  return !left;
        if (side === 'opp') return left;
      }
      return true; // 'both'
    }

    // PRESS-ONLY events (0,2,4,6)
    function extractEvents(src, side){
      const events = []; const bfTimes = []; const oppTimes = [];
      const sections = src.sections || [];

      for (const sec of sections) {
        const notes   = (sec && typeof sec === 'object' && 'sectionNotes' in sec) ? sec.sectionNotes : sec;
        const mustHit = (sec && typeof sec === 'object' && 'mustHitSection' in sec) ? !!sec.mustHitSection : undefined;
        if (!Array.isArray(notes)) continue;

        for (const n of notes) {
          const got = readNoteTriple(n); if (!got) continue;
          let { t, nd } = got;

          nd = ((nd % 8) + 8) % 8;
          if (side !== 'both' && !belongsToSide(nd, side, mustHit)) continue;

          const col = nd % 4;               // 0..3
          const pressLane = col * 2;        // 0,2,4,6

          if (side === 'both') {
            if (belongsToSide(nd, 'bf', mustHit))  bfTimes.push(t);
            if (belongsToSide(nd, 'opp', mustHit)) oppTimes.push(t);
          } else if (side === 'bf') {
            bfTimes.push(t);
          } else if (side === 'opp') {
            oppTimes.push(t);
          }
          events.push({ t, lane: pressLane });
        }
      }
      return { events, bfTimes, oppTimes };
    }

    // Build Gpop
    function toGpop(allEvents, opts, anchorMs) {
      if (!allEvents.length) return [HEADER, opts.seconds ? 0.0 : 0];

      allEvents.sort((a,b)=> (a.t - b.t) || (a.lane - b.lane));

      const anchor = (anchorMs != null) ? anchorMs : (opts.shift ? allEvents[0].t : 0);

      const converted = allEvents.map(ev => {
        const dt = ev.t - anchor;
        const tVal = opts.seconds ? Number(((dt / 1000) + opts.offset).toFixed(3))
                                  : Math.round(dt + opts.offset * 1000);
        return { lane: ev.lane, t: tVal };
      }).sort((a,b)=> (a.t - b.t) || (a.lane - b.lane));

      const seen = new Set();
      const out = [HEADER];
      let lastT = opts.seconds ? 0.0 : 0;

      for (const e of converted) {
        const key = `${e.lane}|${e.t}`;
        if (seen.has(key)) continue;
        seen.add(key);
        out.push(e.lane, e.t);
        lastT = e.t;
      }

      if (opts.nudge) {
        const tick = opts.seconds ? 0.001 : 1;
        const nudged = opts.seconds ? Number((lastT - tick).toFixed(3)) : (lastT - tick);
        out.push(Math.max(0, nudged));
      } else {
        out.push(lastT);
      }
      return out;
    }

    function addAll(dst, src){ for (let i = 0; i < src.length; i++) dst.push(src[i]); }
    function safeMin(arr){ if (!arr || arr.length === 0) return null; let m = arr[0]; for (let i = 1; i < arr.length; i++) if (arr[i] < m) m = arr[i]; return m; }

    function convertFNFToGpop(raw, opts){
      const src = loadFNF(raw);
      const sides = (opts.side === 'both') ? ['bf','opp'] : [opts.side];

      const allEvents = [];
      const bfTimes = [];
      const oppTimes = [];

      for (const s of sides) {
        const { events, bfTimes: b, oppTimes: o } = extractEvents(src, s);
        addAll(allEvents, events);
        addAll(bfTimes,  b);
        addAll(oppTimes, o);
      }

      let anchorMs = null;
      if (allEvents.length) {
        if (opts.anchor === 'bf_start'  && bfTimes.length) {
          const m = safeMin(bfTimes); if (m != null) anchorMs = m;
        } else if (opts.anchor === 'opp_start' && oppTimes.length) {
          const m = safeMin(oppTimes); if (m != null) anchorMs = m;
        } else if (opts.anchor === 'none') {
          anchorMs = null; // respect shift later
        }
      }

      const output = toGpop(allEvents, opts, anchorMs);
      return { output, noteCount: allEvents.length };
    }
  </script>
</body>
</html>
